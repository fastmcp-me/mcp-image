/**
 * Gemini API client for image generation
 * Integrates with Google's Gemini AI API using the official SDK
 */

import { GoogleGenAI } from '@google/genai'
import type { Result } from '../types/result'
import { Err, Ok } from '../types/result'
import type { Config } from '../utils/config'
import { GeminiAPIError, NetworkError } from '../utils/errors'

/**
 * Basic types for Gemini API responses
 */
interface ContentPart {
  inlineData?: {
    data: string
    mimeType: string
  }
}

interface ResponseContent {
  parts?: ContentPart[]
}

interface ResponseCandidate {
  content?: ResponseContent
}

interface GeminiResponse {
  response: {
    candidates?: ResponseCandidate[]
  }
}

interface GenerativeModel {
  generateContent(content: unknown[]): Promise<GeminiResponse>
}

interface GeminiClientInstance {
  getGenerativeModel(config: { model: string }): GenerativeModel
}

interface ErrorWithCode extends Error {
  code?: string
}

/**
 * Metadata for generated images
 */
export interface GenerationMetadata {
  model: string
  prompt: string
  mimeType: string
  timestamp: Date
  inputImageProvided: boolean
}

/**
 * Parameters for image generation
 */
export interface GenerateImageParams {
  prompt: string
  inputImage?: Buffer
}

/**
 * Result of image generation
 */
export interface GeneratedImageResult {
  imageData: Buffer
  metadata: GenerationMetadata
}

/**
 * Gemini API client interface
 */
export interface GeminiClient {
  generateImage(
    params: GenerateImageParams
  ): Promise<Result<GeneratedImageResult, GeminiAPIError | NetworkError>>
}

/**
 * Implementation of Gemini API client
 */
class GeminiClientImpl implements GeminiClient {
  private readonly model: GenerativeModel
  private readonly modelName = 'gemini-2.5-flash-image-preview'

  constructor(private readonly genai: GeminiClientInstance) {
    this.model = this.genai.getGenerativeModel({
      model: this.modelName,
    })
  }

  async generateImage(
    params: GenerateImageParams
  ): Promise<Result<GeneratedImageResult, GeminiAPIError | NetworkError>> {
    try {
      // Prepare the request content
      const requestContent: unknown[] = [params.prompt]

      // Add input image if provided
      if (params.inputImage) {
        requestContent.push({
          inlineData: {
            data: params.inputImage.toString('base64'),
            mimeType: 'image/jpeg', // Assume JPEG for input images
          },
        })
      }

      // Generate content using Gemini API
      const response = await this.model.generateContent(requestContent)

      // Extract image data from response
      const candidates = response.response.candidates
      if (!candidates || candidates.length === 0) {
        return Err(
          new GeminiAPIError(
            'No image generated by Gemini API',
            'Try rephrasing your prompt or check if the model supports your request type'
          )
        )
      }

      const candidate = candidates[0]
      if (!candidate) {
        return Err(
          new GeminiAPIError(
            'No candidate found in Gemini API response',
            'The API response was malformed. Try again or contact support if the issue persists'
          )
        )
      }
      const parts = candidate.content?.parts
      if (!parts || parts.length === 0) {
        return Err(
          new GeminiAPIError(
            'No image data in response from Gemini API',
            'The API response was malformed. Try again or contact support if the issue persists'
          )
        )
      }

      // Find the image part
      const imagePart = parts.find((part: ContentPart) => part.inlineData)
      if (!imagePart?.inlineData) {
        return Err(
          new GeminiAPIError(
            'No image data found in Gemini API response',
            'The model may not have generated an image. Try a different prompt'
          )
        )
      }

      // Convert base64 image data to Buffer
      const imageBuffer = Buffer.from(imagePart.inlineData.data, 'base64')
      const mimeType = imagePart.inlineData.mimeType || 'image/png'

      // Create metadata
      const metadata: GenerationMetadata = {
        model: this.modelName,
        prompt: params.prompt,
        mimeType,
        timestamp: new Date(),
        inputImageProvided: !!params.inputImage,
      }

      return Ok({
        imageData: imageBuffer,
        metadata,
      })
    } catch (error) {
      return this.handleError(error, params.prompt)
    }
  }

  private handleError(
    error: unknown,
    prompt: string
  ): Result<never, GeminiAPIError | NetworkError> {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'

    // Check if it's a network error
    if (this.isNetworkError(error)) {
      return Err(
        new NetworkError(
          `Network error during image generation: ${errorMessage}`,
          'Check your internet connection and try again',
          error instanceof Error ? error : undefined
        )
      )
    }

    // Check if it's an API-specific error
    if (this.isAPIError(error)) {
      return Err(
        new GeminiAPIError(
          `Failed to generate image: ${errorMessage}`,
          this.getAPIErrorSuggestion(errorMessage),
          this.extractStatusCode(error)
        )
      )
    }

    // Generic API error
    return Err(
      new GeminiAPIError(
        `Failed to generate image with prompt "${prompt}": ${errorMessage}`,
        'Check your API key, quota, and prompt validity. Try again with a different prompt'
      )
    )
  }

  private isNetworkError(error: unknown): boolean {
    if (error instanceof Error) {
      const networkErrorCodes = ['ECONNRESET', 'ECONNREFUSED', 'ETIMEDOUT', 'ENOTFOUND']
      return networkErrorCodes.some(
        (code) => error.message.includes(code) || (error as ErrorWithCode).code === code
      )
    }
    return false
  }

  private isAPIError(error: unknown): boolean {
    if (error instanceof Error) {
      const apiErrorKeywords = ['quota', 'rate limit', 'unauthorized', 'forbidden', 'api key']
      return apiErrorKeywords.some((keyword) => error.message.toLowerCase().includes(keyword))
    }
    return false
  }

  private getAPIErrorSuggestion(errorMessage: string): string {
    const lowerMessage = errorMessage.toLowerCase()

    if (lowerMessage.includes('quota') || lowerMessage.includes('rate limit')) {
      return 'You have exceeded your API quota or rate limit. Wait before making more requests or upgrade your plan'
    }

    if (lowerMessage.includes('unauthorized') || lowerMessage.includes('api key')) {
      return 'Check that your GEMINI_API_KEY is valid and has the necessary permissions'
    }

    if (lowerMessage.includes('forbidden')) {
      return 'Your API key does not have permission for this operation'
    }

    return 'Check your API configuration and try again'
  }

  private extractStatusCode(error: unknown): number | undefined {
    if (error && typeof error === 'object' && 'status' in error) {
      return typeof error.status === 'number' ? error.status : undefined
    }
    return undefined
  }
}

/**
 * Creates a new Gemini API client
 * @param config Configuration containing API key and other settings
 * @returns Result containing the client or an error
 */
export function createGeminiClient(config: Config): Result<GeminiClient, GeminiAPIError> {
  try {
    const genai = new GoogleGenAI({
      apiKey: config.geminiApiKey,
    }) as unknown as GeminiClientInstance
    return Ok(new GeminiClientImpl(genai))
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    return Err(
      new GeminiAPIError(
        `Failed to initialize Gemini client: ${errorMessage}`,
        'Verify your GEMINI_API_KEY is valid and the @google/genai package is properly installed'
      )
    )
  }
}
